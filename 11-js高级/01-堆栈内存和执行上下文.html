<script>
    // js高级    之前听过的    就当复习了  
    
    // 目的：
    //  1）笔试   
    //  2）能看懂一些源码   jq   vue-router   vuex    minivuerouter   minivuex
    //  3）更有利于学习vue  react

    // js代码在js解释器运行时，分两个阶段：
    //  1）js代码预编译   
    //  2）js代码执行

    // 编程语言分类：
    // 1）编译性     代码--》计算可以识别的代码   c   c++  只需要编译一次
    //        需要有一个编译器   以后运行的都是编译后的代码  性能高
    // 2）解释性    有一个解释器    代码--》计算可以识别的代码  js  python
    //        每一次运行代码都是要重新进行解释   性能低

    // js代码段：一个script就是一个js代码段 

    // 每一个阶段做的事情是不一样的
    // 预编译阶段：
    //     把加var的变量进行提升  变量的声明提升了  赋值是没有的提升  提升到了代码段最前面
    //     把function声明的函数也进行提升  和变量的提升不一样   函数名和函数值都进行提升


    // var a = 110; // 变量的声明+变量的赋值
    // var a;  变量的声明    提升的都是变量的声明
    // a = 110;  变量的赋值  不会提升
    // var name = "xxx";

    // function f(){  // 使用function关键字声明了一个函数 函数名是f  函数的值就是函数体
    //     console.log("f....")
    // }

    // 现在写代码基本上不会用加var变量   一般要么是let   要第是const
    // 但是有些面试题中有加var变量
</script>

<!-- ----------------------------------- -->

<script>
    // 下面的代码在解释器运行时，分与两个阶段
    //   1）预编译  把加var的变量提升   提升到代码段最前面    把function声明的函数（函数名和函数值）都进行提升
    //   2）执行 代码一行一行执行
    // var a = 1;
    // var b = 2;
    // function f(){
    //     console.log("f...")
    // }
    // var g = function(){  // 不是函数声明   函数表达式  本质还是变量 
    //     console.log("g...")
    // }

    // --------------------- 提升
    // var a;
    // var b;
    // function f(){console.log("f...")}
    // var g;

    // --------------------- 执行  该赋值就赋值   该执行就执行
    // a = 1;  // 赋值
    // b = 2;  // 赋值
    // g = function(){console.log("g...")}
</script>

<!-- ----------------------------------- -->

<script>
    // 看几个题目
    // console.log(a);  // undefiend   js解释器在运行代码时分成两个阶段：预编译  执行
    // var a = 111;
    // console.log(a);  // 111

    // console.log(i);
    // for(var i=0; i<2; i++){
    //     console.log("for....")
    // }
    // console.log(i)

    // console.log(a,b)  // un  un 
    // for(var a=1; a<2; a++){
    //     for(var b=1; b<2; b++){

    //     }
    // }
    // console.log(a,b)  // 2 2

    // 是加var的变量才会提升  没有var的变量不会提升
    // 代码是一行一行执行的 执行91行时  内存中并没有存储a
    // 打印a时，报了a没有定义
    // 记住：undefiend 是 定义了 没有赋值  
    //       not defined  是 压根就没有定义
    // console.log(a)  // a is not defined  报错了  有的报错  后面的代码就不再执行
    // a = 1;
    // console.log(a)

    // 总结：
    // 1）什么是声明：在js中 可以使用var声明一个变量  使用function声明一个函数
    // 2）提升声明：加var   function
    // 3）预编译  执行
</script>

<!-- ----------------------------------- -->

<script>
    // 全局代码和局部代码
    // 一个函数就是一个局部代码，函数之外的代码叫全局代码

    // var a = 1;  // 在函数之外写的代码叫全局代码
    // function f(){  // 函数声明f就是一个函数代码
    //     console.log("f...")
    // }

    // 全局代码在执行时会产生全局的执行上下文（Execution context）（EC）
    // 局部代码在执行时会产生局部的执行上下文（Execution context）

    // 执行上下文都放在执行上下文栈中  栈是先进后出的结构  （杯子中放鸡蛋） ECStack

    // var a = 1;  // 全局代码肯定要产生全局的执行下文
    // function g(){
    //     console.log("g....")
    // }
    // function f(){
    //     g(); // 函数调用  肯定会产生一个局部执行上下文
    //     console.log("f...")
    // }
    // f(); // 是函数执行时才能产生函数的执行上下文  声明是不会产生的

    // ECStack  Execution context Stack  执行上下文栈
    // EC 执行上下文  包含两个东西：VO（变量对象）  AO（活动对象）
    //   全局EC   EC(G)
    //   局部EC
    // Scope 作用域 
    // Scope Chain 作用域链
</script>

<!-- ----------------------------------- -->

<script>
// 加var的变量和不加var的变量到底有什么区别
// 1）在全局代码中  加var的变量会提升  没有var的变量不会提升
// console.log(a); // a is not defiend
// a = 1;

// 2）在全局代码中  加var的变量和不加var的变量都会作为window对象的属性
// var a = 1;  // 全局变量
// b = 2;  // 全局变量
// console.log(window.a)
// console.log(window.b)

// 3)在局部代码，没有var的变量也是全局变量，也会作为window的属性
// function f(){
//     a = 1; // 全局变量  也会作为window的属性
// }
// f();
// console.log(window.a)

// 4) 在局部代码，加var的变量是局部变量，不会作为window的属性
// function f(){
//     var a = 1; // 全局局部  不会作为window的属性
// }
// f();
// // 访问一个对象上没有属性得到的是undefiend
// console.log(window.a) // 你尝试访问一个对象上面不存在的属性 结果？

// 5）没有var的变量都是全局变量  都会作为window的属性
//    一定要避免使用没有var的变量  js 7天时间   灵活

// 6）手动删除一个对象上的属性  加var的变量不能被删除  不加var的可以被删除
// var a = 1; 
// b = 2;
// delete a;
// delete b;
// console.log(a) // 1  加var的变量通过delete是删除不掉的
// console.log(b) // b is not defined  删除了 内存就没有了  
</script>

<!-- ----------------------------------- -->

<script>
// 做一个小题目
// var n = 100;
// console.log(n); 
// console.log(window.n);
// m = 200;
// console.log(m)
// console.log(x)

// 函数内部的局部变量，不会提升到代码段的最前面，仅仅提升到函数代码块的最前面
// console.log(a); // a is not defined a是局部变量   在全局代码中是不能访问局部变量的
// function f(){
//     console.log(a)
//     var a = 1;  // 此处的a也会提升  提升到了函数代码块的最前面
//     console.log(a)
// }
// f()
</script>

<!-- ----------------------------------- -->

<script>
// 不管什么条件，只要是的全局加var的变量 都会进行提升
// console.log(a, b)
// if(true){
//     var a = 1;
// }else{
//     var b = 2;
// }
// console.log(a, b)

// let obj = {
//     name:"wangcai",
//     age:100
// }
// in 仅仅是一个运算符  和 typeof一样
// console.log("name" in obj)  // in是一个运算符 用来判断一个对象有没有这个属性

// var a; 
// console.log(a)  // und 
// if(("a" in window)){
//     a = 110;
// }
// console.log(a) // 100

// console.log(a)  //und
// if(("a" in window)){
//     var a = 110;
// }
// console.log(a) // 100

</script>

<!-- ----------------------------------- -->

<script>
    // var a = 110; // 全局变量  它会作为GO的属性
    // console.log(a)
    // console.log(window.a)

    // function f(){    // 也是全局的函数
    //     console.log("f...")
    //     function g(){  // 函数里面的函数是不能挂载到GO上的
    //         console.log("g...")
    //     }
    // }
    // f() // 先不考虑函数的执行上下文
    // window.f(); // f也会作为window的方法 
    // 尝试去GO中找g  g没有 是undeined   undefiend()
    // g is not a function 
    // window.g(); // g is not a function

</script>

<!-- ----------------------------------- -->

<script>
// 在JS中基本数据类型存储在栈区  引用数据类型存储在堆区
// var a = 1;   // 画图分析了  看分析的图片
// var b = "hello";
// function f(){
//     console.log("f....")
// }
// var arr = [1,2,3]

// function f(a){
//     console.log(a) // 形参a 可以当作是函数内部的局部变量
// }
// f(1)
// console.log(a)
</script>


<!-- ----------------------------------- -->

<script>
// 画下面的题的图
// var arr = [11,22];
// function f(ary){
//     // console.log(ary)
//     ary[0] = 100;
//     // console.log(ary)
//     ary = [666];
//     // console.log(ary)
//     ary[0] = 0;
//     console.log(ary)
// }
// f(arr)
// console.log(arr)

// 看到题  脑子里开始画图分析  画的多了  脑子里自然就有图了
// var arr = [11,22];
// function f(ary){
//     console.log(ary)
//     ary[0] = 100;
//     ary = [666];
//     ary[0] = 0;
//     console.log(ary)
// }
// f(arr)
// console.log(arr)
</script>

<!-- ----------------------------------- -->

<script>
//  直接看图
// function f(){
//     console.log(a)
//     var a = 1;
//     console.log(a)
// }
// f()

// var a = 1;
// var b = 2;

// var a = b = 2; // var a = 2; b = 2;
// delete a;
// console.log(a) // 2
// delete b;
// console.log(b) //  b is not defined

// var a = 1, b = 2; // var a = 1; var b = 2;
// delete a;
// console.log(a)
// delete b;
// console.log(b)

// var a = 1;  也有对应的图  直接看图
// var b = 1;
// function f(){
//     console.log(a, b)  // undefined 1
//     var a = b = 2;
//     console.log(a, b) // 2 2
// }
// f()
// console.log(a, b) // 1 2
</script>

<!-- ----------------------------------- -->

<script>

// 父函数  // 全局代码是没有父函数的
// function f(){  // f的父函数就是全局代码
//     function g(){  // g的父函数就f

//     }
// }
</script>

<!-- ----------------------------------- -->

<script>
// var a = 1;
// var obj = {
//     name:"wangcai"
// }
// function f(){
//     var a2 = a;
//     obj2 = obj;
//     a2 = a;
//     obj2.name = "xiaoqiang"
// }
// f();
// console.log(a)
// console.log(obj)
</script>

<!-- ----------------------------------- -->

<script>
// 使用let或const声明变量有什么优势
// 1）let 声明的变量没有提升
// console.log(a) // 理解1）let声明的变量是不会提升    2）let声明的变量提升  但是没有赋值  没有赋值  你是不能获取
// let a = 1; // ReferenceError: Cannot access 'a' before initialization

// 2）let+{}会形成块级作用域
// if(true){ var a = 100; }  console.log(a) // 100  a全局变量
// 由于let外面包了一个{}  只能在这个{}内部访问a 
// {}内部叫块级作用域  在块级作用域之外是不能访问它里面的数据
// if(true){ let a = 100; }  console.log(a) // a is not defined

// 3）let声明的变量不会挂载到GO上
// let a = 1;
// console.log(window.a) // undefined

// 4）let不能重复声明
// var a = 1;  重复声明是不足
// var a = 2;
// let a = 1;
// let a = 2;
// console.log(a); // 'a' has already been declared

// 开发中基本都是let来声明变量   const来声明常量

// const声明的变量是不能修改的，所以说也叫常量
// let a = 1;
// a = 2;
// a = 3;
// console.log(a);// 3 变量

// const b = 1;  // const声明的变量是不能修改（常量）
// b = 2;
// console.log(b) // Assignment to constant variable.

// const也不能重复声明  
// const也不能提声

// const和let的区别：const不能修改变量的值（常量）



</script>

<!-- ----------------------------------- -->

<script>
    // f()  // 之所以可以在这里调用函数  原因在下面的函数声明和赋值都提升
    // function f(){
    //     console.log("f....")
    // }

    // g()
    // console.log(a)
    // var a = 110;
    // function g(){
    //     k()
    //     console.log(b)
    //     console.log("g..")
    //     var b = 2;
    //     console.log(b)

    //     function k(){
    //         console.log("k....")
    //     }
    // }
    // g();

    // 函数表达式  本质是一个变量  这个变量的值是函数
    // 提升仅仅是变量的声明  var f 后面值是不会提升
    // f() // 在函数表达式上面调用，不OK，因为你仅仅是提升f
    //     // f这个值还是und   und()  f is not a function
    // var f = function(){
    //     console.log("f...")
    // }
    // f()
        
    // 函数表达式可以指定函数名  但是外面不能通过这个函数名调用这个函数
    // 这个函数名是可以在函数内部使用
    // var k = function x(){  // 函数表达式也可以指定函数名
    //     console.log(x) // var a = 110;  x是函数名  
    //     console.log("666")   
    // }
    // // x() // x is not defined
    // k()

    // console.log(x) // x is not defined
    // var k = function x(){
    // }


</script>

<!-- ----------------------------------- -->

<script>
    // console.log(fn)  // 函数
    // // window.fn() // window.fn is not a function
    // // console.log(window.fn)  // undefined
    // // fn()  // fn...
    // // 对于函数声明的提升  如果有条件  结果是什么？
    // if("fn" in window){
    //     fn()  // fn...
    //     function fn(){
    //         console.log("fn...")
    //     }
    // }
    // // fn() // fn...


    // console.log(fn) 
    // fn() 
    // if("fn" in window){
    //     fn()  
    //     function fn(){
    //         console.log("fn...")
    //     }
    // }
</script>

<!-- ----------------------------------- -->

<script>
    // fn()
    // function fn(){ console.log(1) }
    // fn()
    // function fn(){ console.log(2) }
    // fn()
    // var fn = function(){ console.log(3) }
    // fn()
    // function fn(){ console.log(4) }
    // fn()
    // function fn(){ console.log(5) }
    // fn()

    // function g(){
    //     console.log("111")
    // }
    // var g = function(){
    //     console.log("222")
    // }
    // g()
</script>

<!-- ----------------------------------- -->

<script>
    // 画图
    // let a = 12;
    // var b = a;
    // b = 13;
    // console.log(a)

    // let a = {n:12}
    // let b = a; 
    // b['n'] = 13;
    // console.log(a.n)

    // let a = {n:12}
    // let b = a; 
    // b = {n:13}
    // console.log(a.n)

</script>

<!-- ----------------------------------- -->

<script>
    // let a = {
    //     n:110
    // }
    // let b = a;
    // b = b.m = {
    //     n:666
    // }
    // console.log(a)
    // console.log(b)

    // console.log(f)
    // console.log(a)
    // var a = 10;
    // function f(){
    //     console.log(b)
    //     var b = 20;
    //     console.log(b)
    // }
    // f()  
    // console.log(a)
    // console.log(f)
</script>

<!-- ----------------------------------- -->

<script>
    // // 先声明一个函数  然后调用
    // function f(){
    //     console.log("f...")
    // }
    // f(); // 调用 在任何地方手动调用

    // 自执行函数  
    // (function f(){
    //     console.log(".....")
    // })()
</script>

<!-- ----------------------------------- -->

<script>
// -------- 题目1
// console.log(a)
// if(!('a' in window)){
//     var a = 1;
// }
// console.log(a)

// -------- 题目2
// 在js中有的代码出错了，后面的代码不会执行
// console.log(f)  // 由于下面的funciton是在条件中  仅仅是把函数名提升  值是没有提升  und
// f() // und()  报错   因为und不能当作函数   f is not funciotn
// // 由于下面的报错了  下面的代码就不再执行了
// // 当然JS中有的错误，不影响后面代码的执行
// if('f' in window){
//     f()
//     function f(){ // 在一个条件中 仅仅提升函数名 可以把f当成变量
//         console.log("f...")
//     }
// }
// f()

// -------- 题目3  先放一下
// f = function(){ return true; }
// g = function(){ return false; }
// (function(){
//     if(g() && [] == ![]){
//         f = function(){ return false; }
//         function g(){ return true}
//     }
// })();
// console.log(f())
// console.log(g())

// -------- 题目4
// console.log(a,b)
// var a = 12, 
//     b = 12;
// function fn(){
//     console.log(a, b);
//     var a = b = 13;
//     console.log(a, b)
// }
// fn()
// console.log(a, b)

// -------- 题目5  不画了
// console.log(a, b, c)
// var a = 12, 
//     b = 13, 
//     c = 14;
// function fn(a){  // 形参是函数内部的局部变量
//     console.log(a, b, c)
//     a = 100;  // 是函数内部的局部变量a
//     c = 200;  // 全局的c
//     console.log(a, b, c)
// }
// b = fn(10);
// console.log(a, b, c)

// -------- 题目6
// function sum(a){  // 形参是函数内部的局部变量
//     console.log(a);  // SyntaxError: Identifier 'a' has already been declared
//     let a = 100;  // let不能重复声明 
//     console.log(a);
// }
// sum(200)

// -------- 题目7
// var ary = [12,23]
// function fn(ary){
//     console.log(ary)
//     ary[0] = 100;
//     ary = [100]
//     ary[0] = 0;
//     console.log(ary)
// }
// fn(ary)
// console.log(ary)

// -------- 题目8
// var i = 0;
// function A(){
//     var i = 10;
//     function x(){
//         console.log(i)
//     }
//     return x;
// }
// var y = A();
// y();
// function B(){
//     var i = 20;
//     y()
// }
// B()

// -------- 题目9


// -------- 题目10
// -------- 题目11
// -------- 题目12
// -------- 题目13
// -------- 题目14
</script>

<!-- ----------------------------------- -->

<script>
// ======================  作业
// let a = 0; 
//     b = 0; 
// function A(a){
//     A = function(b){
//         alert(a+b++)
//     }
//     alert(a++)
// }
// A(1);
// A(2);
</script>

<!-- ----------------------------------- -->

<script>
// var a 肯定会提升  
// 代码从上到下开始执行  ECStack EC(全局) 
// var a  VO  声明的全局变量会保存到VO
// 声明的全局变量也会保存到GO一份，把全局变量作为window的一个属性
// var a = 12;  12赋值给a所指向的内存空间
// VO中的a里面就保存了12
// 一旦VO中的a发生了改变   GO中的a也会跟着改变
// console.log(a)
// var a = 12;
// a = 13;  // 把13赋值给a所指定的内存空间  VO中的a所对应栈内存空间中数据就变成了13
// // GO中的a所对应的数据也会发生改变 
// console.log(a)
// console.log(window.a)
</script>

<!-- ----------------------------------- -->

<script>
// 预编译：看没有没var   看有没有function  过
// 代码开始执行：ECStack  EC(G)  VO  VO中没有保存数据
// console.log(a)  // a is not defined   找a 先去VO中找  找不到  然后去GO中找  由于下面的代码还没有执行  GO中也没有数据   就报错了
// window.a = 13;

 
// window.a = 13;  // 相当于给GO中放了一个a属性
// console.log(a) // 13  // 先去VO中找，找不到，就去GO中找 

// var a = 110; // 把a放VO一份  然后放到GO一份   其中a的值变了   VO和GO中的值都会改变
// window.a = 110; // 此时a仅仅是window的属性  a仅存在GO中的  VO中是没有的

// 预编译：var  function  过
// window.a = 13;  // 向GO中放一个a
// console.log(a)  // 先去VO（加var的全局变量才会放到vo中）中找  然后去GO中找  找到了  a的值是13
// a = 14; // 14赋值给a所对应的内存空间  找a  先去VO中找  找不到  再才GO中找  GO中有a  14赋值给GO中a所对应的内存空间
// console.log(window.a)  // 直接去GO中找  14
// console.log(a)  // a 先去VO中找  找不到  再去GO中找  找到了  14
</script>

<!-- ----------------------------------- -->

<script>
// let和var最大区别？
//    let/const创建的变量，不存在变量的提升
//    只有var 和 funciotn声明变量和函数才有提升

// import xx from "vue"  也是创建了一个变量xx  xx也不会提升

// let声明的是全局变量  放到VO中一份
// let声明的变量 不会放到GO的
// let a = 12;
// a = 13;  // 13赋值给a所对应的内存空间  找a  先去VO中找  找到了  13
// console.log(a)  // 先去VO中找   找到了  13 
// console.log(window.a) // 明确了要去GO中找   GO中是没有的
</script>

<!-- ----------------------------------- -->

<script>

</script>


<!-- ----------------------------------- -->

<script>
// 提升   x   y   fn 
// EC(G)
//    VO
//       x = 100 ==> 1000
//       y = 100
//       fn = 0xabc
// GO
//    x = 100 ==> 1000
//    y = 100
//    z = 300
// var x = 100,
//     y = 100;
// function fn(){   // fn的父函数是全局代码产生的EC  就是EC(G)
//     // EC(fn)  入栈
//     //   AO
//     //     y = 200
//     var y = 200;
//     console.log(x); // 100 // 找x  先在自己的EC中找 就去父函数所对应的EC中的
//     x = 1000;  // 把1000赋给x所对应栈内存  找x   就去父函数所对应的EC中的
//     console.log(y); // 200 // 找y   先在自己的EC中找  有  就使用自己EC中的y
//     // console.log(z); // 找z     先在自己的EC中找  没有  就去父函数所对应的EC中的 也没有  然后去GO中的  GO中也没有z  就报错
//     z = 300 // 把300赋值给z所指向的内存空间  找z  自己EC 没有   找父EC  没有  把z挂到GO上，作为window的一属性
// }
// fn()
// console.log(z)
// console.log(window.z)
</script>

<!-- ----------------------------------- -->

<script>
// EC(G)
//   VO
//     var a  1
//     fn  0xabc
// GO
//     var a  1
//     fn
// var a = 1;  
// function fn(a){
//     // EC(fn)  1)形参赋值
//     //   形参也是局部变量
//     //   AO
//     //      a = 1
//     //        = 函数
//     //        = 函数 ===>  2
//     //  执行
//     console.log(a)  // 函数
//     var a = 2;  // AO中有a  就不再提升  
//     function a(){}
//     console.log(a)  // 2
// }
// fn(a)
// console.log(a) // 1

// 如果变量名和函数名是相同的 函数先提升
// 预编译：
//    f ==》函数
//       var f也要提升  由于f之前提升过了  就不会提升
// 执行：
//    f = 2  
//    funciton f(){}  在预编译期间就处理过了  过
//    log(f)  ==> 2 
// var f = 2;
// function f(){}
// console.log(f)


// var a = 1;  
// function fn(a){
//     console.log(a)  
//     var a = 2; 
//     function a(){}
//     console.log(a)  
// }
// fn(a)
// console.log(a) 

</script>

<!-- ----------------------------------- -->

<script>
// EC(G)
//    VO
//       var a 1
//       func b  0x123
// GO
//    var a 1
//    func b 0x123
// var a = 1;
// function b(){
//     // EC(b)
//     //   AO
//     //     var a und
//     if(!a){  // und默认转成false 
//         var a = 2;  // 赋值操作  
//     }
//     console.log(a)  // 2
// }
// b()

</script>

<!-- ----------------------------------- -->

<!-- <script>
// EC(G)
//    VO
//      var a  und ==> 10
//      var b  und ==> 11
//      var c  und ==> 12 ==> 3
//      f  0x113
var a = 10, b = 11, c = 12;
function f(a){
    // EC(f)
    //    AO
    //     a  10 ==> 1
    //     b  und ==> 2 
    a = 1;
    var b = 2;
    c = 3; // 把3赋给c所对应的内存空间  找c  EC(f)没有  就去EC(G)找
}
f(10)
console.log(a)
console.log(b)
console.log(c)
</script> -->

<!-- ----------------------------------- -->

<!-- <script>
// EC(G)
//    VO
//       var a  und 
// GO
//    a  und
// 
if(!('a' in window)){
    var a = 110;
}
console.log(a)
</script> -->
<!-- ----------------------------------- -->

<!-- <script>
    // arguments  
    // 在每一个函数内部都有一个arguments 用收集实参
    // 只能在函数内部使用arguemnts 
    function f(x,y,z){
        console.log(x,y,z)
        // arguments会收集实参  实参你不只赋值给了形参
        // 你也把实参扔到arugments中
        // argumetns是一个伪数组 不是真正的数据
        console.log(arguments)
    }
    // arguments is not defined
    console.log(arguments)
    f(1,2,3)
</script> -->


<!-- ----------------------------------- -->

<!-- <script>
function f(x,y,z){
    // console.log(x,y,z,arguments)
    // 虽然arguments是一个伪数组，也可以通过下标进行访问和设置
    // arguments[0] = 100; 

    // argumentst和形参之间有一一对应的关系  一个改变另一个也会改变
    // console.log(arguments)
    // console.log(x)

    // 改变了形参肯定会影响arguments  改变了argumetns肯定也会影响形参的值
    // y = 200;
    // console.log(y)
    // console.log(arguments)

    // arguments[2] = 300;
    // console.log(x,y,z)
}
f(1,2,3)
</script> -->

<!-- ----------------------------------- -->

<!-- <script>
var a = 4;
function f(x,y,a){
    console.log(a)
    arguments[2] = 10;
    console.log(a)
}
a = f(1,2,3);
console.log(a)
</script> -->

<!-- ----------------------------------- -->

<script>

</script>

<!-- ----------------------------------- -->

<script>

</script>

<!-- ----------------------------------- -->

<script>

</script>




















